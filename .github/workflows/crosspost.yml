name: Cross-post to dev.to and Medium

on:
  push:
    branches: [main]
    paths:
      - '_posts/**'
  workflow_dispatch:
    inputs:
      post_path:
        description: 'Path to post file (e.g., _posts/2024-12-25-my-post.markdown)'
        required: false
        type: string

jobs:
  crosspost:
    name: Cross-post to platforms
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Need previous commit to detect changed files

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm install gray-matter

      - name: Cross-post to platforms
        env:
          DEVTO_API_KEY: ${{ secrets.DEVTO_API_KEY }}
          MEDIUM_INTEGRATION_TOKEN: ${{ secrets.MEDIUM_INTEGRATION_TOKEN }}
          SITE_URL: https://karun.me
        run: |
          node << 'EOF'
          const fs = require('fs');
          const path = require('path');
          const matter = require('gray-matter');
          const { execSync } = require('child_process');

          const SITE_URL = process.env.SITE_URL;
          const DEVTO_API_URL = 'https://dev.to/api/articles';
          const MEDIUM_API_URL = 'https://api.medium.com/v1';
          const DEVTO_TRACKING_FILE = '.devto-posts.json';
          const MEDIUM_TRACKING_FILE = '.medium-posts.json';

          // Load tracking file
          function loadTracking(file) {
            if (fs.existsSync(file)) {
              return JSON.parse(fs.readFileSync(file, 'utf8'));
            }
            return {};
          }

          // Save tracking file
          function saveTracking(file, tracking) {
            fs.writeFileSync(file, JSON.stringify(tracking, null, 2) + '\n');
          }

          // Convert Jekyll markdown to cross-post format
          function convertMarkdown(content, frontmatter, postPath) {
            let converted = content;

            // Remove <!-- more --> excerpt separator
            converted = converted.replace(/<!--\s*more\s*-->/gi, '');

            // Convert {% highlight lang %}...{% endhighlight %} to markdown code fences
            converted = converted.replace(
              /\{%\s*highlight\s+(\w+)\s*%\}([\s\S]*?)\{%\s*endhighlight\s*%\}/g,
              (match, lang, code) => `\`\`\`${lang}\n${code.trim()}\n\`\`\``
            );

            // Convert {% post_url YYYY-MM-DD-slug %} to absolute URLs
            converted = converted.replace(
              /\{%\s*post_url\s+(\d{4}-\d{2}-\d{2})-([^\s%]+)\s*%\}/g,
              (match, date, slug) => `${SITE_URL}/blog/${slug}/`
            );

            // Convert {% include youtube.html id="..." title="..." %} to YouTube embed
            converted = converted.replace(
              /\{%\s*include\s+youtube\.html\s+id="([^"]+)"(?:\s+title="([^"]+)")?\s*%\}/g,
              (match, id, title) => `{% embed https://www.youtube.com/watch?v=${id} %}`
            );

            // Replace {{ site.url }} with actual URL
            converted = converted.replace(/\{\{\s*site\.url\s*\}\}/g, SITE_URL);

            // Replace {{ site.excerpt_separator }} with empty
            converted = converted.replace(/\{\{\s*site\.excerpt_separator\s*\}\}/g, '');

            // Convert relative image paths to absolute URLs
            converted = converted.replace(
              /!\[([^\]]*)\]\((?!http)([^)]+)\)/g,
              (match, alt, src) => {
                const absoluteSrc = src.startsWith('/') ? `${SITE_URL}${src}` : `${SITE_URL}/${src}`;
                return `![${alt}](${absoluteSrc})`;
              }
            );

            // Convert relative links to absolute URLs
            converted = converted.replace(
              /\[([^\]]+)\]\((?!http|#)([^)]+)\)/g,
              (match, text, href) => {
                const absoluteHref = href.startsWith('/') ? `${SITE_URL}${href}` : `${SITE_URL}/${href}`;
                return `[${text}](${absoluteHref})`;
              }
            );

            return converted.trim();
          }

          // Convert YouTube embed for Medium (uses standard markdown link)
          function convertMarkdownForMedium(content) {
            // Convert dev.to embed syntax to plain YouTube link for Medium
            return content.replace(
              /\{%\s*embed\s+https:\/\/www\.youtube\.com\/watch\?v=([^\s%]+)\s*%\}/g,
              (match, id) => `https://www.youtube.com/watch?v=${id}`
            );
          }

          // Generate canonical URL from post filename
          function getCanonicalUrl(postPath) {
            const filename = path.basename(postPath, '.markdown');
            const match = filename.match(/^(\d{4})-(\d{2})-(\d{2})-(.+)$/);
            if (!match) {
              throw new Error(`Invalid post filename format: ${postPath}`);
            }
            const [, year, month, day, slug] = match;
            return `${SITE_URL}/blog/${slug}/`;
          }

          // Get platforms to cross-post to from front matter
          function getPlatforms(frontmatter) {
            // New format: cross_post: [devto, medium]
            if (frontmatter.cross_post && Array.isArray(frontmatter.cross_post)) {
              return frontmatter.cross_post;
            }
            // Legacy format: devto: true
            if (frontmatter.devto === true) {
              return ['devto'];
            }
            return [];
          }

          // ============== DEV.TO ==============

          async function createDevtoArticle(article) {
            const response = await fetch(DEVTO_API_URL, {
              method: 'POST',
              headers: {
                'api-key': process.env.DEVTO_API_KEY,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({ article })
            });

            if (!response.ok) {
              const error = await response.text();
              throw new Error(`dev.to API error (${response.status}): ${error}`);
            }

            return response.json();
          }

          async function postToDevto(postPath, frontmatter, content, tracking) {
            if (!process.env.DEVTO_API_KEY) {
              console.log('  âš ï¸  DEVTO_API_KEY not set, skipping dev.to');
              return false;
            }

            if (tracking[postPath]) {
              console.log(`  â­ï¸  dev.to: Already posted (ID: ${tracking[postPath].id})`);
              return false;
            }

            const canonicalUrl = getCanonicalUrl(postPath);
            const convertedContent = convertMarkdown(content, frontmatter, postPath);

            const article = {
              title: frontmatter.title,
              body_markdown: convertedContent,
              canonical_url: canonicalUrl,
              published: true
            };

            if (frontmatter.description) {
              article.description = frontmatter.description;
            }

            // dev.to allows max 4 tags, lowercase alphanumeric only
            let tags = frontmatter.devto_tags || frontmatter.tags;
            if (tags && Array.isArray(tags)) {
              article.tags = tags
                .slice(0, 4)
                .map(t => t.toLowerCase().replace(/[^a-z0-9]/g, ''));
            }

            try {
              const result = await createDevtoArticle(article);
              console.log(`  âœ… dev.to: ${result.url}`);

              tracking[postPath] = {
                id: result.id,
                url: result.url,
                posted_at: new Date().toISOString()
              };
              return true;
            } catch (error) {
              console.error(`  âŒ dev.to: ${error.message}`);
              throw error;
            }
          }

          // ============== MEDIUM ==============

          let mediumUserId = null;

          async function getMediumUserId() {
            if (mediumUserId) return mediumUserId;

            const response = await fetch(`${MEDIUM_API_URL}/me`, {
              headers: {
                'Authorization': `Bearer ${process.env.MEDIUM_INTEGRATION_TOKEN}`,
                'Content-Type': 'application/json',
                'Accept': 'application/json'
              }
            });

            if (!response.ok) {
              const error = await response.text();
              throw new Error(`Medium API error getting user (${response.status}): ${error}`);
            }

            const data = await response.json();
            mediumUserId = data.data.id;
            return mediumUserId;
          }

          async function createMediumPost(userId, post) {
            const response = await fetch(`${MEDIUM_API_URL}/users/${userId}/posts`, {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${process.env.MEDIUM_INTEGRATION_TOKEN}`,
                'Content-Type': 'application/json',
                'Accept': 'application/json'
              },
              body: JSON.stringify(post)
            });

            if (!response.ok) {
              const error = await response.text();
              throw new Error(`Medium API error (${response.status}): ${error}`);
            }

            return response.json();
          }

          async function postToMedium(postPath, frontmatter, content, tracking) {
            if (!process.env.MEDIUM_INTEGRATION_TOKEN) {
              console.log('  âš ï¸  MEDIUM_INTEGRATION_TOKEN not set, skipping Medium');
              return false;
            }

            if (tracking[postPath]) {
              console.log(`  â­ï¸  Medium: Already posted (ID: ${tracking[postPath].id})`);
              return false;
            }

            const canonicalUrl = getCanonicalUrl(postPath);
            const convertedContent = convertMarkdown(content, frontmatter, postPath);
            const mediumContent = convertMarkdownForMedium(convertedContent);

            const userId = await getMediumUserId();

            const post = {
              title: frontmatter.title,
              contentFormat: 'markdown',
              content: mediumContent,
              publishStatus: 'draft'  // Create as draft - user sets canonical and publishes manually
            };

            // Medium allows max 5 tags
            let tags = frontmatter.medium_tags || frontmatter.tags;
            if (tags && Array.isArray(tags)) {
              post.tags = tags.slice(0, 5);
            }

            try {
              const result = await createMediumPost(userId, post);
              console.log(`  âœ… Medium (DRAFT): ${result.data.url}`);

              tracking[postPath] = {
                id: result.data.id,
                url: result.data.url,
                posted_at: new Date().toISOString(),
                status: 'draft'
              };

              // Add to job summary for manual action reminder
              const summaryFile = process.env.GITHUB_STEP_SUMMARY;
              if (summaryFile) {
                const summary = `
## ðŸ“ Medium Draft Created - Manual Action Required

**Post:** ${frontmatter.title}
**Draft URL:** ${result.data.url}

### Steps to publish:
1. Open the draft URL above
2. Review formatting
3. Click "..." â†’ "This story was originally published elsewhere"
4. Enter canonical URL: \`${canonicalUrl}\`
5. Ensure "Free" is selected (not member-only)
6. Click Publish
7. (Optional) Add to inspiredbrilliance publication

`;
                fs.appendFileSync(summaryFile, summary);
              }

              return true;
            } catch (error) {
              console.error(`  âŒ Medium: ${error.message}`);
              throw error;
            }
          }

          // ============== MAIN ==============

          function getPostsToProcess() {
            const manualPath = '${{ github.event.inputs.post_path }}';

            if (manualPath) {
              return [manualPath];
            }

            try {
              const output = execSync('git diff --name-only HEAD~1 HEAD -- _posts/', { encoding: 'utf8' });
              return output.trim().split('\n').filter(f => f.endsWith('.markdown'));
            } catch (e) {
              console.log('Could not get changed files, checking all posts');
              return fs.readdirSync('_posts').filter(f => f.endsWith('.markdown')).map(f => `_posts/${f}`);
            }
          }

          async function main() {
            const devtoTracking = loadTracking(DEVTO_TRACKING_FILE);
            const mediumTracking = loadTracking(MEDIUM_TRACKING_FILE);
            const posts = getPostsToProcess();

            console.log(`Found ${posts.length} post(s) to check\n`);

            let devtoChanges = false;
            let mediumChanges = false;

            for (const postPath of posts) {
              if (!fs.existsSync(postPath)) {
                console.log(`Skipping ${postPath} - file not found`);
                continue;
              }

              const fileContent = fs.readFileSync(postPath, 'utf8');
              const { data: frontmatter, content } = matter(fileContent);
              const platforms = getPlatforms(frontmatter);

              if (platforms.length === 0) {
                console.log(`Skipping ${postPath} - no cross_post platforms specified`);
                continue;
              }

              console.log(`Processing ${postPath}`);
              console.log(`  Platforms: ${platforms.join(', ')}`);

              for (const platform of platforms) {
                if (platform === 'devto') {
                  const posted = await postToDevto(postPath, frontmatter, content, devtoTracking);
                  if (posted) {
                    devtoChanges = true;
                    // Rate limit
                    await new Promise(resolve => setTimeout(resolve, 15000));
                  }
                } else if (platform === 'medium') {
                  const posted = await postToMedium(postPath, frontmatter, content, mediumTracking);
                  if (posted) {
                    mediumChanges = true;
                    // Rate limit
                    await new Promise(resolve => setTimeout(resolve, 5000));
                  }
                } else {
                  console.log(`  âš ï¸  Unknown platform: ${platform}`);
                }
              }

              console.log('');
            }

            if (devtoChanges) {
              saveTracking(DEVTO_TRACKING_FILE, devtoTracking);
              console.log('dev.to tracking file updated');
            }

            if (mediumChanges) {
              saveTracking(MEDIUM_TRACKING_FILE, mediumTracking);
              console.log('Medium tracking file updated');
            }

            if (!devtoChanges && !mediumChanges) {
              console.log('No new posts to cross-post');
            }
          }

          main().catch(err => {
            console.error(err);
            process.exit(1);
          });
          EOF

      - name: Commit tracking files
        if: success()
        run: |
          has_changes=false

          if [ -f .devto-posts.json ] && ! git diff --quiet .devto-posts.json 2>/dev/null; then
            has_changes=true
          fi

          if [ -f .medium-posts.json ] && ! git diff --quiet .medium-posts.json 2>/dev/null; then
            has_changes=true
          fi

          if [ "$has_changes" = true ]; then
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add .devto-posts.json .medium-posts.json 2>/dev/null || true
            git commit -m "Update cross-post tracking"
            git push
          fi
