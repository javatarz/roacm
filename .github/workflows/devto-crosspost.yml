name: Cross-post to dev.to

on:
  push:
    branches: [main]
    paths:
      - '_posts/**'
  workflow_dispatch:
    inputs:
      post_path:
        description: 'Path to post file (e.g., _posts/2024-12-25-my-post.markdown)'
        required: false
        type: string

jobs:
  crosspost:
    name: Cross-post to dev.to
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Need previous commit to detect changed files

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm install gray-matter

      - name: Cross-post to dev.to
        env:
          DEVTO_API_KEY: ${{ secrets.DEVTO_API_KEY }}
          SITE_URL: https://karun.me
        run: |
          node << 'EOF'
          const fs = require('fs');
          const path = require('path');
          const matter = require('gray-matter');
          const { execSync } = require('child_process');

          const DEVTO_API_URL = 'https://dev.to/api/articles';
          const TRACKING_FILE = '.devto-posts.json';
          const SITE_URL = process.env.SITE_URL;

          // Load tracking file
          function loadTracking() {
            if (fs.existsSync(TRACKING_FILE)) {
              return JSON.parse(fs.readFileSync(TRACKING_FILE, 'utf8'));
            }
            return {};
          }

          // Save tracking file
          function saveTracking(tracking) {
            fs.writeFileSync(TRACKING_FILE, JSON.stringify(tracking, null, 2) + '\n');
          }

          // Convert Jekyll markdown to dev.to format
          function convertMarkdown(content, frontmatter, postPath) {
            let converted = content;

            // Remove <!-- more --> excerpt separator
            converted = converted.replace(/<!--\s*more\s*-->/gi, '');

            // Convert {% highlight lang %}...{% endhighlight %} to markdown code fences
            converted = converted.replace(
              /\{%\s*highlight\s+(\w+)\s*%\}([\s\S]*?)\{%\s*endhighlight\s*%\}/g,
              (match, lang, code) => `\`\`\`${lang}\n${code.trim()}\n\`\`\``
            );

            // Convert {% post_url YYYY-MM-DD-slug %} to absolute URLs
            converted = converted.replace(
              /\{%\s*post_url\s+(\d{4}-\d{2}-\d{2})-([^\s%]+)\s*%\}/g,
              (match, date, slug) => `${SITE_URL}/blog/${slug}/`
            );

            // Convert {% include youtube.html id="..." title="..." %} to YouTube embed
            converted = converted.replace(
              /\{%\s*include\s+youtube\.html\s+id="([^"]+)"(?:\s+title="([^"]+)")?\s*%\}/g,
              (match, id, title) => `{% embed https://www.youtube.com/watch?v=${id} %}`
            );

            // Replace {{ site.url }} with actual URL
            converted = converted.replace(/\{\{\s*site\.url\s*\}\}/g, SITE_URL);

            // Replace {{ site.excerpt_separator }} with empty
            converted = converted.replace(/\{\{\s*site\.excerpt_separator\s*\}\}/g, '');

            // Convert relative image paths to absolute URLs
            // Handles: ![alt](/assets/images/...) and ![alt](assets/images/...)
            converted = converted.replace(
              /!\[([^\]]*)\]\((?!http)([^)]+)\)/g,
              (match, alt, src) => {
                const absoluteSrc = src.startsWith('/') ? `${SITE_URL}${src}` : `${SITE_URL}/${src}`;
                return `![${alt}](${absoluteSrc})`;
              }
            );

            // Convert relative links to absolute URLs
            converted = converted.replace(
              /\[([^\]]+)\]\((?!http|#)([^)]+)\)/g,
              (match, text, href) => {
                const absoluteHref = href.startsWith('/') ? `${SITE_URL}${href}` : `${SITE_URL}/${href}`;
                return `[${text}](${absoluteHref})`;
              }
            );

            return converted.trim();
          }

          // Generate canonical URL from post filename
          function getCanonicalUrl(postPath) {
            // Extract date and slug from filename: _posts/YYYY-MM-DD-slug.markdown
            const filename = path.basename(postPath, '.markdown');
            const match = filename.match(/^(\d{4})-(\d{2})-(\d{2})-(.+)$/);
            if (!match) {
              throw new Error(`Invalid post filename format: ${postPath}`);
            }
            const [, year, month, day, slug] = match;
            return `${SITE_URL}/blog/${slug}/`;
          }

          // Create new article on dev.to
          async function createArticle(article) {
            const response = await fetch(DEVTO_API_URL, {
              method: 'POST',
              headers: {
                'api-key': process.env.DEVTO_API_KEY,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({ article })
            });

            if (!response.ok) {
              const error = await response.text();
              throw new Error(`dev.to API error (${response.status}): ${error}`);
            }

            return response.json();
          }

          // Get posts to process
          function getPostsToProcess() {
            const manualPath = '${{ github.event.inputs.post_path }}';

            if (manualPath) {
              // Manual trigger - process specific post
              return [manualPath];
            }

            // Push trigger - get changed files in _posts/
            try {
              const output = execSync('git diff --name-only HEAD~1 HEAD -- _posts/', { encoding: 'utf8' });
              return output.trim().split('\n').filter(f => f.endsWith('.markdown'));
            } catch (e) {
              console.log('Could not get changed files, checking all posts');
              return fs.readdirSync('_posts').filter(f => f.endsWith('.markdown')).map(f => `_posts/${f}`);
            }
          }

          // Main execution
          async function main() {
            const tracking = loadTracking();
            const posts = getPostsToProcess();

            console.log(`Found ${posts.length} post(s) to check`);

            let hasChanges = false;

            for (const postPath of posts) {
              if (!fs.existsSync(postPath)) {
                console.log(`Skipping ${postPath} - file not found`);
                continue;
              }

              const fileContent = fs.readFileSync(postPath, 'utf8');
              const { data: frontmatter, content } = matter(fileContent);

              // Check if post should be cross-posted
              if (!frontmatter.devto) {
                console.log(`Skipping ${postPath} - devto: true not set`);
                continue;
              }

              // Skip if already posted (create-only, no updates)
              if (tracking[postPath]) {
                console.log(`Skipping ${postPath} - already posted (ID: ${tracking[postPath].id})`);
                continue;
              }

              console.log(`Creating ${postPath}...`);

              const canonicalUrl = getCanonicalUrl(postPath);
              const convertedContent = convertMarkdown(content, frontmatter, postPath);

              // Prepare dev.to article
              const article = {
                title: frontmatter.title,
                body_markdown: convertedContent,
                canonical_url: canonicalUrl,
                published: true
              };

              // Add description if present
              if (frontmatter.description) {
                article.description = frontmatter.description;
              }

              // Add tags (dev.to allows max 4 tags)
              // Use devto_tags if specified, otherwise fall back to existing tags
              let tags = frontmatter.devto_tags || frontmatter.tags;
              if (tags && Array.isArray(tags)) {
                // dev.to tags: lowercase, alphanumeric only (no hyphens allowed)
                article.tags = tags
                  .slice(0, 4)
                  .map(t => t.toLowerCase().replace(/[^a-z0-9]/g, ''));
              }

              try {
                const result = await createArticle(article);
                console.log(`✅ Created: ${result.url}`);

                // Track the post
                tracking[postPath] = {
                  id: result.id,
                  url: result.url,
                  posted_at: new Date().toISOString()
                };
                hasChanges = true;

                // Rate limit: dev.to is strict, wait 15s between posts
                await new Promise(resolve => setTimeout(resolve, 15000));
              } catch (error) {
                console.error(`❌ Failed to create ${postPath}: ${error.message}`);
                process.exit(1);
              }
            }

            if (hasChanges) {
              saveTracking(tracking);
              console.log('Tracking file updated');
            } else {
              console.log('No new posts to cross-post');
            }
          }

          main().catch(err => {
            console.error(err);
            process.exit(1);
          });
          EOF

      - name: Commit tracking file
        if: success()
        run: |
          if [ -f .devto-posts.json ] && ! git diff --quiet .devto-posts.json 2>/dev/null; then
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add .devto-posts.json
            git commit -m "Update dev.to cross-post tracking"
            git push
          fi
