<!doctype html>
<html lang="en-US">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="Description" content="Karun Japhet's blog">
  <title>Ramblings of a Coder's Mind by Karun Japhet</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!--[if lt IE 9]>
  <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
</head>

  <body>
    <div class="wrapper">
      <header>
  <h1 class="header"><a href="/">Ramblings of a Coder's Mind</a></h1>
  <p class="header">Got Tech? Will Hack.</p>
</header>


      <section>
        <section>
  <h1 class="entry-title">Version controlled configuration and secrets management for Terraform</h1>
  <p><a href="https://www.terraform.io/" target="_blank" rel="noopener noreferrer">Terraform</a> is a tool to build your infrastructure as code. We’ve been having a few challenges while trying to figure out how to how to manage configuration and secrets when integrating terraform with our CD pipeline.</p>

<!-- more -->
<h2 id="life-before-version-control">Life before version control</h2>
<p>Before we can do that, it’s important to understand build process before we began on this journey.
<a href="https://blog.karun.me/assets/images/uploads/terraform-environments.jpg"><img src="https://blog.karun.me/assets/images/uploads/terraform-environments.jpg" alt="Terraform managed environments"></a></p>

<p>Our build model for this project was branch based. Each environment maps to a branch (<code>main -&gt; dev</code>, <code>uat -&gt; uat</code> and <code>production -&gt; production</code>). All other (feature) branches only ran the plan stage against the <code>dev</code> environment.</p>

<p>As you can notice, the configurations, secrets and keys are all maintained on the build agent. This means, every developer wanting to run plan and test their changes needs to replicate the <code>terraform_variables</code> directory. Any mistakes in doing so masks actual issues that your pipeline might face leading to delayed feedback.</p>

<p>Next, let’s look at what our codebase looked like</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">terraform
├── module-1
│   ├── backend.tf
│   ├── data.tf
│   ├── resources.tf
│   ├── provider.tf
│   └── variables.tf
├── module-2
│   ├── backend.tf
│   ├── data.tf
│   ├── resources.tf
│   ├── provider.tf
│   └── variables.tf
└── scripts
    └── provision
        ├── apply.sh
        ├── init.sh
        └── plan.sh</code></pre></figure>

<p>The provisioning scripts help us consistently run different stages across modules. Each module is an independent area of our infrastructure (such as core networking, HTTP services etc.)</p>

<p>Each of the provisioning scripts accepted a <code>WORKSPACE_NAME</code> (branch for execution that maps to the environment terraform is running for) and <code>MODULE_NAME</code> (module being executed).</p>

<p><code>init.sh</code> ran the <code>terraform init</code> stage of the pipeline downloading the necessary plugins and initializing the backend</p>
<noscript><pre>#!/bin/bash
set -e

cd $MODULE_NAME

echo "init default.tfstate"
terraform init -backend-config="key=default.tfstate"

echo "select or create new workspace $WORKSPACE_NAME"
terraform workspace select $WORKSPACE_NAME || terraform workspace new $WORKSPACE_NAME

echo "init $MODULE_NAME/terraform.tfstate"
terraform init -backend-config="key=$MODULE_NAME/terraform.tfstate" -force-copy -reconfigure</pre></noscript>
<script src="https://gist.github.com/javatarz/52c755ca164de009f1e37bebfdac46ea.js"> </script>

<p><code>plan.sh</code> ran the <code>terraform plan</code> stage allowing users to review their changes before applying them.</p>
<noscript><pre>#!/bin/bash
set -e

cd $MODULE_NAME

echo "select or create new workspace $WORKSPACE_NAME"
terraform workspace select $WORKSPACE_NAME || terraform workspace new $WORKSPACE_NAME

echo "plan with var file ~/terraform_variables/$WORKSPACE_NAME/$MODULE_NAME.tfvars"
terraform plan -var-file=~/terraform_variables/$WORKSPACE_NAME/$MODULE_NAME.tfvars -out=$MODULE_NAME.tfplan -input=false</pre></noscript>
<script src="https://gist.github.com/javatarz/5ab158cd0aa7ba492872cff7061d8814.js"> </script>

<p><code>apply.sh</code> applied the changes onto an environment. Developers do not run this command from local to ensure consistency on the environment</p>
<noscript><pre>#!/bin/bash
set -e

cd $MODULE_NAME

echo "select or create new workspace $WORKSPACE_NAME"
terraform workspace select $WORKSPACE_NAME || terraform workspace new $WORKSPACE_NAME

echo "apply with var file ~/terraform_variables/$WORKSPACE_NAME/$MODULE_NAME.tfvars"
terraform apply -var-file=~/terraform_variables/$WORKSPACE_NAME/$MODULE_NAME.tfvars -auto-approve</pre></noscript>
<script src="https://gist.github.com/javatarz/48795c981c5495d38184a4cf52a1cd2c.js"> </script>

<h2 id="version-controlling-configuration">Version controlling configuration</h2>
<p>We moved the variables into the <code>config</code> directory by making a directory for every branch for each of the 3 environments we had.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">terraform
├── config
│   ├── main
│   │   ├── module-1.tfvars
│   │   └── module-2.tfvars
│   ├── production
│   │   ├── module-1.tfvars
│   │   └── module-2.tfvars
│   ├── uat
│   │   ├── module-1.tfvars
│   │   └── module-2.tfvars
├── module-1
│   └── ...
├── module-2
|   └── ...
└── scripts
    ├── provision
    │   ├── apply.sh
    │   ├── functions.sh
    │   ├── init.sh
    │   └── plan.sh
    └── test_variable_names.sh</code></pre></figure>

<p>According to <a href="https://www.terraform.io/docs/configuration/variables.html#environment-variables" target="_blank" rel="noopener noreferrer">terraform’s documentation</a>, you can export a variable that your terraform codes need with a prefix of <code>TF_VAR</code>.</p>

<p><code>functions.sh</code> provides convenience functions to read the configuration and secrets.</p>
<noscript><pre>#!/bin/bash

function fetch_variables() {
    workspace_name=$1
    module_name=$2

    echo $(cat ../config/$workspace_name/$module_name.tfvars | sed '/^$/D' | sed 's/.*/TF_VAR_&amp; /' | tr -d '\n')
}</pre></noscript>
<script src="https://gist.github.com/javatarz/d9314848516e919952fbfc7c681a5488.js"> </script>

<p><code>fetch_variables</code> read the <code>tfvars</code> file, removes empty lines (that were added for readability), prefixed the name with <code>TF_VAR</code> and joined all entries into a single line. The string this method returns can be used as a prefix to the <code>terraform</code> command while running <code>plan</code> and <code>apply</code> making them environment variables.</p>

<p><em>Updated plan and apply scripts are placed in the secrets management section for brevity</em></p>

<h3 id="testing-configuration-files">Testing configuration files</h3>
<p>The only limitation is that <strong>none of these variables can have a hyphen</strong> in the name because of <a href="https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Definitions" target="_blank" rel="noopener noreferrer">shell variable naming rules</a>. As with any potential mistake, a test providing feedback helps protect you from run time failures. <code>test_variable_names.sh</code> does this check for us.</p>

<noscript><pre>#!/bin/bash

function parse_and_test_properties_entries() {
    prop=$1
    if [[ "$prop" == "" || $prop = \#* ]]; then
        continue
    fi

    key="$(cut -d'=' -f1 &lt;&lt;&lt;"$prop")"
    if [[ $key =~ "-" ]]; then
        echo "$filename contains \"$key\" which contains a hyphen"
        exit 1
    fi
}

function parse_file() {
    filename=$1
    OLD_IFS=$IFS
    props=$(cat $filename)

    IFS=$'\n'
    for prop in ${props[@]}; do
        parse_and_test_properties_entries $prop
    done
    IFS=$OLD_IFS
}

base_dir="config"
for sub_dir in $(find $base_dir -mindepth 1 -maxdepth 1 -type d); do
    workspace_name=${sub_dir#"$base_dir/"}

    for input_file in config/$workspace_name/*.tfvars; do
        parse_file $input_file
    done

    echo "All variables are named correctly in config/$workspace_name"
done</pre></noscript>
<script src="https://gist.github.com/javatarz/1497470a61c9f06689deaaf19a1610e1.js"> </script>

<h2 id="version-controlling-secrets">Version controlling secrets</h2>
<p>Secrets like passwords can be version controlled in a similar way though they require encryption to keep them safe. We’re using <a href="https://www.openssl.org/" target="_blank" rel="noopener noreferrer">OpenSSL</a> with a <a href="https://en.wikipedia.org/wiki/Symmetric-key_algorithm" target="_blank" rel="noopener noreferrer">symmetric key</a> to encrypt our secrets. Each secret is put into a <code>tfsecrets</code> file (internally a property file just like <code>tfvars</code> files for configuration). When encrypted, the file will have an extension of <code>.tfsecrets.enc</code>. When the <code>plan</code> or <code>apply</code> stages are executed, files are decrypted <strong>in memory</strong> (and not on disk, for security reasons) and used the same way.</p>

<p><code>functions.sh</code> gets a new addition to support reading all secrets</p>
<noscript><pre>function fetch_secrets() {
    workspace_name=$1
    module_name=$2
    secret_key_for_workspace=$(eval "echo \$SECRET_KEY_$workspace_name")
    echo $(openssl enc -aes-256-cbc -d -in ../config/$workspace_name/$module_name.tfsecrets.enc -pass pass:$secret_key_for_workspace | sed '/^$/D' | sed 's/.*/TF_VAR_&amp; /' | tr -d '\n')
}</pre></noscript>
<script src="https://gist.github.com/javatarz/f78a72e02ce9aced0636d61672a2b777.js"> </script>

<p>The astute amongst you probably noticed that we’re using OpenSSL v1.0.2s because v1.1.x changes the syntax on encryption/decryption of files. Also, you might have noticed the use of environment variables like <code>SECRET_KEY_main</code>, <code>SECRET_KEY_uat</code> and <code>SECRET_KEY_production</code> as the encryption keys. These values are stored on our CI server (in our case <a href="https://gitlab.com/" target="_blank" rel="noopener noreferrer">GitLab</a>) which makes these values available to our CI agent during execution.</p>

<p>For local development, we have scripts to encrypt and decrypt configuration files either one at a time or in bulk per environment. It’s worth noting that re-encryption of the same file will show up on your <code>git diff</code> since the encrypted file’s metadata changes. Only check in encrypted files when their contents have changed (helping you debug future issues)</p>

<p><code>encrypt.sh</code> takes <code>SECRET_KEY</code> as an environment variable for making local usage easier.</p>
<noscript><pre>#!/bin/bash
set -e

if [ -z "$SECRET_KEY" ]; then
    echo "Set a SECRET_KEY for \"$WORKSPACE_NAME\" encryption"
    exit 1
fi

function encrypt_file() {
    input_file=$1
    target_file="$input_file.enc"
    echo "Encrypting $input_file to $target_file"
    openssl enc -aes-256-cbc -salt -in $input_file -out $target_file -pass pass:$SECRET_KEY
    rm -f $input_file
}

if [ -z $1 ]; then
    echo "Usage:"
    echo "  ./scripts/encrypt.sh &lt;filePathFromProjectRoot&gt;"
    echo "  ./scripts/encrypt.sh all"
    exit 2
elif [ "$1" == "all" ]; then
    for input_file in config/$WORKSPACE_NAME/*.tfsecrets; do
        encrypt_file $input_file
    done
else
    encrypt_file $1
fi</pre></noscript>
<script src="https://gist.github.com/javatarz/8775d0d2a9ad124eefff9df6b2d431eb.js"> </script>

<p><code>decrypt.sh</code> also takes the same <code>SECRET_KEY</code> as an environment variable for making local usage easier.</p>
<noscript><pre>#!/bin/bash
set -e

if [ -z "$SECRET_KEY" ]; then
    echo "Set a SECRET_KEY for \"$WORKSPACE_NAME\" decryption"
    exit 1
fi

function decrypt_file() {
    input_file=$1
    target_file=${input_file%".enc"}
    echo "Decrypting $input_file to $target_file"
    openssl enc -aes-256-cbc -d -in $input_file -out $target_file -pass pass:$SECRET_KEY
    rm -f $input_file
}

if [ -z $1 ]; then
    echo "Usage:"
    echo "  ./scripts/decrypt.sh &lt;filePathFromProjectRoot&gt;"
    echo "  ./scripts/decrypt.sh all"
    exit 2
elif [ "$1" == "all" ]; then
    for input_file in config/$WORKSPACE_NAME/*.tfsecrets.enc
    do
        decrypt_file $input_file
    done
else
    decrypt_file $1
fi</pre></noscript>
<script src="https://gist.github.com/javatarz/f1e33a666587f4ade051e725e196742e.js"> </script>

<h3 id="testing-secret-files">Testing secret files</h3>
<p>If all files for an environment aren’t checked with the same key, you’ll face a runtime error. Since files can be encrypted individually, you must test if all files have been encrypted correctly. This test is also useful when you’re rotating the <code>SECRET_KEY</code> for an environment.</p>

<p><code>test_encryption.sh</code> needs <code>SECRET_KEY_&lt;env&gt;</code> values set so it can be executed locally.</p>
<noscript><pre>#!/bin/bash

base_dir="config"

for sub_dir in $(find $base_dir -mindepth 1 -maxdepth 1 -type d); do
    workspace_name=${sub_dir#"$base_dir/"}
    password_var_name="\$SECRET_KEY_$workspace_name"
    secret_key_for_workspace=$(eval "echo $password_var_name")

    if [ -z "$secret_key_for_workspace" ]; then
        echo "Variable $password_var_name has not been set. Unable to test"
        exit 1
    fi

    for input_file in config/$workspace_name/*.tfsecrets.enc
    do
        openssl enc -aes-256-cbc -d -in $input_file -pass pass:$secret_key_for_workspace &amp;&gt; /dev/null
        if [ $? != 0 ]; then
            echo "Unable to decrypt $input_file with $password_var_name"
            exit 1
        fi
    done

    echo "Successfully decrypted all secrets in config/$workspace_name"
done</pre></noscript>
<script src="https://gist.github.com/javatarz/5aedf7066b408511975d3cb97ce0ee5a.js"> </script>

<h3 id="end-result">End result</h3>
<p>Our final project structure contains the following files</p>
<pre><code>terraform
├── config
│   ├── main
│   │   ├── module-1.tfvars
│   │   ├── module-1.tfsecrets.enc
│   │   ├── module-2.tfvars
│   │   └── module-2.tfsecrets.enc
│   ├── production
│   │   ├── module-1.tfvars
│   │   ├── module-1.tfsecrets.enc
│   │   ├── module-2.tfvars
│   │   └── module-2.tfsecrets.enc
│   ├── uat
│   │   ├── module-1.tfvars
│   │   ├── module-1.tfsecrets.enc
│   │   ├── module-2.tfvars
│   │   └── module-2.tfsecrets.enc
├── module-1
│   └── ...
├── module-2
|   └── ...
└── scripts
    ├── decrypt.sh
    ├── encrypt.sh
    ├── provision
    │   ├── apply.sh
    │   ├── functions.sh
    │   ├── init.sh
    │   └── plan.sh
    ├── test_encryption.sh
    └── test_variable_names.sh
</code></pre>

<p><code>plan.sh</code> uses <code>functions.sh</code> to load configuration and secrets</p>
<noscript><pre>#!/bin/bash
set -e

source $(dirname "$0")/functions.sh

cd $MODULE_NAME

echo "select or create new workspace $WORKSPACE_NAME"
terraform workspace select $WORKSPACE_NAME || terraform workspace new $WORKSPACE_NAME

echo "plan with var file config/$WORKSPACE_NAME/$MODULE_NAME.tfvars"
config=$(fetch_variables $WORKSPACE_NAME $MODULE_NAME)
secrets=$(fetch_secrets $WORKSPACE_NAME $MODULE_NAME)
eval "$secrets $config terraform plan -out=$MODULE_NAME.tfplan -input=false"</pre></noscript>
<script src="https://gist.github.com/javatarz/3efb6a5d416d4149678b427bc37ff154.js"> </script>

<p><code>apply.sh</code> uses <code>functions.sh</code> in a similar fashion</p>
<noscript><pre>#!/bin/bash
set -e

source $(dirname "$0")/functions.sh

cd $MODULE_NAME

echo "select or create new workspace $WORKSPACE_NAME"
terraform workspace select $WORKSPACE_NAME || terraform workspace new $WORKSPACE_NAME

echo "apply with var file config/$WORKSPACE_NAME/$MODULE_NAME.tfvars"
config=$(fetch_variables $WORKSPACE_NAME $MODULE_NAME)
secrets=$(fetch_secrets $WORKSPACE_NAME $MODULE_NAME)
eval "$secrets $config terraform apply -auto-approve"</pre></noscript>
<script src="https://gist.github.com/javatarz/8e77d8ee1474a4d06faf9a4cc19ec0df.js"> </script>

<p>And thus, our terraform project requires no data from the CI agent and can be executed perfectly from any box as long as it has the latest code checked out and the correct version of terraform.</p>


  <span>
  

  <strong>Created</strong>: 26th August 2019
  
</span>
<br>
  

<span>
  <strong>Category</strong>:
  Tutorial
</span>

<br>
  

<span>
  <strong>Tags</strong>:
  continuous delivery, gitlab, infrastructure as code, terraform, version control
</span>



  
    <h2>Comments</h2>

    <div id="disqus_thread"></div>
    <script>
      var disqus_config = function () {
        this.page.url = 'https://blog.karun.me/blog/2019/08/26/version-controlled-configuration-and-secrets-management-for-terraform/';
        this.page.identifier = 'https://blog.karun.me/blog/2019/08/26/version-controlled-configuration-and-secrets-management-for-terraform/';
      };

      (function() {
        var d = document, s = d.createElement('script');
        s.src = 'https://roacm.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="noopener noreferrer" target="_blank">comments powered by Disqus.</a>
</noscript>
  
</section>

      </section>

      <footer>
  <h3>About</h3>
  <p><a href="https://karun.me" target="_blank" rel="noopener noreferrer">Karun Japhet</a> is a human.<br>Writes code at Sahaj Software. Speaks publicly about scaling software, testing, CD &amp; ML. Loves riding motorcycles and playing CS:GO</p>
  <p><small><a href="/about">Read on →</a></small></p>

  <h3>Contact</h3>
  <p id="contact">
      
      <a href="https://github.com/javatarz" aria-label="GitHub" target="_blank" rel="noopener noreferrer"><i class="fab fa-github fa-lg"></i></a>
      
      <a href="https://stackoverflow.com/users/499797" aria-label="Stack Overflow" target="_blank" rel="noopener noreferrer"><i class="fab fa-stack-overflow fa-lg"></i></a>
      
      <a href="https://twitter.com/javatarz" aria-label="Twitter" target="_blank" rel="noopener noreferrer"><i class="fab fa-twitter fa-lg"></i></a>
      
      <a href="https://www.linkedin.com/in/karunjaphet" aria-label="LinkedIn" target="_blank" rel="noopener noreferrer"><i class="fab fa-linkedin fa-lg"></i></a>
      
      <a href="mailto:karun@japhet.in" rel="tooltip" title="karun@japhet.in" target="_blank"><i class="fa fa-envelope fa-lg"></i></a>
      <a href="/atom.xml" title="RSS Feed" target="_blank" rel="noopener"><i class="fa fa-rss fa-lg"></i></a>
  </p>

  <p>
    <small>
      Copyright © 2006 - 2021 <br>
      <a href="https://karun.me" target="_blank" rel="noopener noreferrer">Karun Japhet</a> <br>
      Powered by <a href="http://jekyllrb.com/" target="_blank" rel="noopener noreferrer">Jekyll</a>
    </small>
  </p>
</footer>

    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    

    

    <noscript id="deferred-styles">
    <link href="https://fonts.googleapis.com/css?family=Arvo:400,700,400italic" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <link rel="stylesheet" href="/assets/css/overrides.css?v=">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/solid.css" integrity="sha384-rdyFrfAIC05c5ph7BKz3l5NG5yEottvO/DQ0dCrwD8gzeQDjYBHNr1ucUpQuljos" crossorigin="anonymous">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/brands.css" integrity="sha384-QT2Z8ljl3UupqMtQNmPyhSPO/d5qbrzWmFxJqmY7tqoTuT2YrQLEqzvVOP2cT5XW" crossorigin="anonymous">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/fontawesome.css" integrity="sha384-u5J7JghGz0qUrmEsWzBQkfvc8nK3fUT7DCaQzNQ+q4oEXhGSx+P2OqjWsfIRB8QT" crossorigin="anonymous">
    <script src="/assets/js/scale.fix.js"></script>
</noscript>
<script>
    var loadDeferredStyles = function() {
    var addStylesNode = document.getElementById("deferred-styles");
    var replacement = document.createElement("div");
    replacement.innerHTML = addStylesNode.textContent;
    document.body.appendChild(replacement)
    addStylesNode.parentElement.removeChild(addStylesNode);
    };
    var raf = window.requestAnimationFrame || window.mozRequestAnimationFrame ||
        window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
    if (raf) raf(function() { window.setTimeout(loadDeferredStyles, 0); });
    else window.addEventListener('load', loadDeferredStyles);
</script>
  </body>
</html>
