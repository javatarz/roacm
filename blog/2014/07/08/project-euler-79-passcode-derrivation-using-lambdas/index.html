<!doctype html>
<html lang="en-US">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="Description" content="Karun Japhet's blog">
  <title>Ramblings of a Coder's Mind by Karun Japhet</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!--[if lt IE 9]>
  <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
</head>

  <body>
    <div class="wrapper">
      <header>
  <h1 class="header"><a href="/">Ramblings of a Coder's Mind</a></h1>
  <p class="header">Got Tech? Will Hack.</p>
</header>


      <section>
        <section>
  <h1 class="entry-title">Project Euler #79: Passcode Derrivation (using Lambdas)</h1>
  <p>I’ve been solving Project Euler for years and I avoid posting solutions online as far as possible but this problem is old enough that it shouldn’t be a problem. Plus, the problem statement interests me enough to write a functional solution using the new Java 8 Lambdas that I’ve been experimenting over the past few months.</p>

<p>Before I begin, I’d like to acknowledge <a href="http://alexmic.net/" target="_blank" rel="noopener noreferrer">Alex Michael</a> for providing the base solution with a pretty nice explanation of how to crack the problem. You should read through <a href="http://alexmic.net/password-derivation-project-euler/" target="_blank" rel="noopener noreferrer">his post</a> before you continue.</p>

<p>My solution provides a Java port of this solution using Lambdas. Here are the steps to the solution</p>

<!-- more -->

<h1 id="solution-process">Solution Process</h1>

<ol>
  <li>Read file to a List of Strings viz. ‘passcodes’</li>
  <li>Process each ‘passcode’ in ‘passcodes’ using a ‘passcodeConsumer’
    1. separate digits of the passcode and add them to a ‘digitUniverse’ set which contains all digits that the solution has
    2. separate digits of the passcode and ‘update connections’
    3. merge connections created for this passcode with past ones</li>
  <li>iterate through every key in the master connection relationship graph considering them as the parent before doing a BFS to find the possible solutions using recursion</li>
</ol>

<h1 id="solution-walkthrough">Solution Walkthrough</h1>

<h2 id="reading-the-passcodes">Reading the passcodes</h2>

<p>We’ve added <a href="https://projecteuler.net/project/keylog.txt" target="_blank" rel="noopener noreferrer">keylog.txt</a> into the project’s build path so we can read it. Thanks to the magic of Java 7’s NIO Files API, it’s a one line job to read files now.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java">final List&lt;String&gt; passcodes = Files.readAllLines(Paths.get("./keylog.txt"));</code></pre></figure>

<p>This can optionally be replaced with the following lines for testing the solution. The explanation further will hinge on these values</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java">final List&lt;String&gt; passcodes = Arrays.asList(new String[] { "123", "125", "536" });</code></pre></figure>

<h2 id="processing-passcodes">Processing passcodes</h2>

<p>This processing requires someone to first iterate through the passcodes, find all digits in the passcode to maintain a unique set of digits required for the overall solution (called the ‘digit universe’) and calculate ‘connections’ between digits (order of appearance of digits in the solution)</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java">final Consumer passcodeConsumer = passcode -&gt; {
    	digitSeparator.apply(passcode).forEach(addToDigitUniverse);
    	digitSeparator.apply(passcode).forEach(updateConnections);

    	connections.entrySet().forEach(connectionMerge);
    	connections.clear();
    };</code></pre></figure>

<p>Each of the lambdas and data structures used here are described below</p>

<h3 id="digit-separator">Digit Separator</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java">final Function&lt;String, IntStream&gt; digitSeparator = str -&gt; str.chars().map(c -&gt; Integer.valueOf(String.valueOf((char) c)));</code></pre></figure>

<p>This function simply iterates through the characters of the string and converts them into integers. As you see, this function will be required multiple times later</p>

<h3 id="maintaining-a-digit-universe">Maintaining a Digit Universe</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java">final Set&lt;Integer&gt; digitUniverse = new HashSet&lt;&gt;();
    final IntConsumer addToDigitUniverse = i -&gt; digitUniverse.add(i);</code></pre></figure>

<p>This is a straight forward function to update the data structure for the digit universe. The chosen data structure is a <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Set.html" target="_blank" rel="noopener noreferrer">Java Set</a> to ensure values are unique. Since the order of appearance isn’t important to us and the <a href="http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html" target="_blank" rel="noopener noreferrer">HashSet</a> implementation’s performance is good enough for our requirement, we can use it.</p>

<h3 id="updating-connections">Updating Connections</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java">final Map&lt;Integer, Set&lt;Integer&gt;&gt; connections = new HashMap&lt;&gt;();

    final IntConsumer updateConnections = digit -&gt; {
    	connections.forEach((key, values) -&gt; values.add(digit));

    	final Set&lt;Integer&gt; set = connections.get(digit);
    	if (set == null) {
    		connections.put(digit, new HashSet&lt;&gt;());
    	}
    };</code></pre></figure>

<p>The connections data structure maintains relationships between digits defining the order which digits occur. For a number 541, the relationship would suggest digits 4 and 1 come after 5 and that the digit 1 comes after 4. When the number 541 is processed, the connections map will contain the following content (assuming it was empty earlier)</p>

<blockquote>
  <p>5 -&gt; [1, 4]</p>

  <p>4 -&gt; [1]</p>

  <p>1 -&gt; []</p>
</blockquote>

<p>The order of appearance inside the Set doesn’t matter. The result here contains 1 before 4 only because the <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Set.html" target="_blank" rel="noopener noreferrer">Set</a> implementation used was a <a href="http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html" target="_blank" rel="noopener noreferrer">HashSet</a> which naturally sorts data (meaning numbers get arranged in ascending order).</p>

<p>It is important to note that the data structure ‘connections’ is <em>temporary</em> and only contains state for the current passcode being processed. This means that the solution cannot be parallelized as long as this state is being maintained. Then again, our solution can’t be parallelized because <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Map.html" target="_blank" rel="noopener noreferrer">Java Maps</a> can’t be streamed. Maybe I’ll update this solution to make it parallel eventually.</p>

<p>The ‘connections’ state is processed to update the master data set of connections by using a custom merge logic.</p>

<h3 id="connection-merging">Connection merging</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java">final Consumer&lt;Map.Entry&lt;Integer, Set&gt;&gt; connectionMerge = entry -&gt; {
    	final Integer key = entry.getKey();
    	final Set&lt;Integer&gt; contenderValues = entry.getValue();
    	Set&lt;Integer&gt; targetValues = masterConnections.get(key);

    	if (targetValues == null) {
    		targetValues = new HashSet&lt;&gt;();
    		masterConnections.put(key, targetValues);
    	}

    	targetValues.addAll(contenderValues);
    };</code></pre></figure>

<p>The connection merge is applied on an entry of the connection data structure. the key and contenderValues are variables that hold information about an entry in the connections map. If the passcode being processed was 541, each of rows mentioned above as being in the connection map (such as “5 -&gt; [1, 4]”) will be an entry this consumer will consume.</p>

<p>The targetValues are a <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Set.html" target="_blank" rel="noopener noreferrer">Set</a> that contains any data that the masterConnections already has for the same key. If the targetValues <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Set.html" target="_blank" rel="noopener noreferrer">Set</a> is null then the digit in the key is being encountered for the first time and so the map will be updated with an empty <a href="http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html" target="_blank" rel="noopener noreferrer">HashSet</a>. Irrespective of whether targetValues existed or not, the next step is to add all the contenderValues into the targetValues <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Set.html" target="_blank" rel="noopener noreferrer">Set</a>. The underlying masterConnections data structure is kept up to date because the maps are backed (the same object reference is used internally to ensure data is kept up to date).</p>

<p>Once the merge is complete the passcodeConsumer has to ensure that the consumer is cleared so it’s ready for the processing of the next passcode</p>

<h2 id="finding-longest-solutions">Finding longest solutions</h2>

<figure class="highlight"><pre><code class="language-java" data-lang="java">masterConnections.forEach((k, v) -&gt; {
    	final String possibleSolution = findPossibleSolution(new LinkedHashSet&lt;&gt;(), k);
    	if (possibleSolution.length() &gt; 0) {
    		System.out.println("Possible Solution: " + possibleSolution + " (Vertex: " + k + ")");
    	}
    });</code></pre></figure>

<p>This step iterates through every entry in the masterConnection map considering that its a master and finds the longest solution for each vertex in the graph. If the possibleSolution length is 0, there was no solution that used all digits in the digitUniverse.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java">private static final String findPossibleSolution(final Set&lt;Integer&gt; parentNodes, final Integer currentNode) {
    	final Set&lt;Integer&gt; childNodes = masterConnections.get(currentNode);
    	parentNodes.add(currentNode);

    	if (childNodes.isEmpty()) {
    		final String candidate = parentNodes.stream().map(i -&gt; i.toString()).collect(Collectors.joining());
    		final boolean valid = digitUniverse.stream().allMatch(i -&gt; candidate.contains(String.valueOf(i)));
    		return valid ? candidate : "";
    	}

    	return childNodes.stream().map(node -&gt; findPossibleSolution(new LinkedHashSet&lt;&gt;(parentNodes), node)).reduce("", (a, b) -&gt; (a.length() &lt;= b.length() ? a : b));
    }</code></pre></figure>

<p>The findPossibleSolution method recursively digs through the child nodes of the currentNode to find child nodes.</p>

<p>When a leaf node is found, the parent nodes are used to trace out the path traversed along the map which represents a candidate solution. The <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Set.html" target="_blank" rel="noopener noreferrer">Set</a> implementation used was a <a href="http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashSet.html" target="_blank" rel="noopener noreferrer">LinkedHashSet</a> to ensure the order of the path traced to the child node is maintained. Validity of each candidate solution is tested to confirm if every one of the digits of the digitUniverse are included in the candidate. If so, the candidate is returned or an empty string is returned.</p>

<p>When the current node is not a leaf node, all child nodes are iterated through and the findPossibleMethod is recursively invoked to generate a solution. The solutions are then reduced to ensure a solution of the least length is returned. If two solutions have the same length, the one which was found first is returned (the choice is arbitrary at that point since the question asks for any valid solution of minimum length is found).</p>

<h2 id="bringing-it-all-together">Bringing it all together</h2>

<p>All you now need is a main function to do your bidding</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java">public static void main(String[] args) throws IOException {
    	final List&lt;String&gt; passcodes = Files.readAllLines(Paths.get("./keylog.txt"));

    	passcodes.forEach(passcodeConsumer);

    	masterConnections.forEach((k, v) -&gt; {
    		final String possibleSolution = findPossibleSolution(new LinkedHashSet&lt;&gt;(), k);
    		if (possibleSolution.length() &gt; 0) {
    			System.out.println("Possible Solution: " + possibleSolution + " (Vertex: " + k + ")");
    		}
    	});
    }</code></pre></figure>

<h2 id="update">Update</h2>

<p>Alex’s original solution assumes that digits will not be repeated. This is an assumption that is validated by the input data set for the problem. But in real life, this does not hold true. If your input is <strong>123</strong> and <strong>325</strong> the only solution you can have is 12325 since the two inputs clearly show that the digit 2 appears before and after 3 (unless the digit 3 is also repeated; which though would be a valid solution, it wouldn’t be an optimal one since the problem requires the shortest answer). This solution cannot be fetched as long as data is stored in <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Set.html" target="_blank" rel="noopener noreferrer">Set</a>s because they wade out repetitions. The implementation can be migrated to use <a href="http://docs.oracle.com/javase/7/docs/api/java/util/List.html" target="_blank" rel="noopener noreferrer">List</a>s instead. The other change required would be the master connections data structure should now possess the ability to track which node connections have been traversed in the recursion. To ensure there is no inappropriate data sharing in the recursion, each recursive call is isolated by performing deep copy on the parent list (and master connections data structures).</p>

<p>include_code lang:java project-euler-79-passcode-derrivation-using-lambdas/PasscodeGenerator.java</p>

<p>The path class simply defines a structure to track nodes and whether they have been traversed yet.</p>

<p>include_code lang:java project-euler-79-passcode-derrivation-using-lambdas/Path.java</p>


  <span>
  

  <strong>Created</strong>: 8th July 2014
  
</span>
<br>
  

<span>
  <strong>Categories</strong>:
  Development, Tutorials
</span>

<br>
  

<span>
  <strong>Tags</strong>:
  Functional Programming, Java 8, Lambda, Project Euler, code sample, java
</span>



  
    <h2>Comments</h2>

    <div id="disqus_thread"></div>
    <script>
      var disqus_config = function () {
        this.page.url = 'https://blog.karun.me/blog/2014/07/08/project-euler-79-passcode-derrivation-using-lambdas/';
        this.page.identifier = 'https://blog.karun.me/blog/2014/07/08/project-euler-79-passcode-derrivation-using-lambdas/';
      };

      (function() {
        var d = document, s = d.createElement('script');
        s.src = 'https://roacm.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="noopener noreferrer" target="_blank">comments powered by Disqus.</a>
</noscript>
  
</section>

      </section>

      <footer>
  <h3>About</h3>
  <p><a href="https://karun.me" target="_blank" rel="noopener noreferrer">Karun Japhet</a> is a human.<br>Writes code at Sahaj Software. Speaks publicly about scaling software, testing, CD &amp; ML. Loves riding motorcycles and playing CS:GO</p>
  <p><small><a href="/about">Read on →</a></small></p>

  <h3>Contact</h3>
  <p id="contact">
      
      <a href="https://github.com/javatarz" aria-label="GitHub" target="_blank" rel="noopener noreferrer"><i class="fab fa-github fa-lg"></i></a>
      
      <a href="https://stackoverflow.com/users/499797" aria-label="Stack Overflow" target="_blank" rel="noopener noreferrer"><i class="fab fa-stack-overflow fa-lg"></i></a>
      
      <a href="https://twitter.com/javatarz" aria-label="Twitter" target="_blank" rel="noopener noreferrer"><i class="fab fa-twitter fa-lg"></i></a>
      
      <a href="https://www.linkedin.com/in/karunjaphet" aria-label="LinkedIn" target="_blank" rel="noopener noreferrer"><i class="fab fa-linkedin fa-lg"></i></a>
      
      <a href="mailto:karun@japhet.in" rel="tooltip" title="karun@japhet.in" target="_blank"><i class="fa fa-envelope fa-lg"></i></a>
      <a href="/atom.xml" title="RSS Feed" target="_blank" rel="noopener"><i class="fa fa-rss fa-lg"></i></a>
  </p>

  <p>
    <small>
      Copyright © 2006 - 2021 <br>
      <a href="https://karun.me" target="_blank" rel="noopener noreferrer">Karun Japhet</a> <br>
      Powered by <a href="http://jekyllrb.com/" target="_blank" rel="noopener noreferrer">Jekyll</a>
    </small>
  </p>
</footer>

    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    

    

    <noscript id="deferred-styles">
    <link href="https://fonts.googleapis.com/css?family=Arvo:400,700,400italic" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <link rel="stylesheet" href="/assets/css/overrides.css?v=">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/solid.css" integrity="sha384-rdyFrfAIC05c5ph7BKz3l5NG5yEottvO/DQ0dCrwD8gzeQDjYBHNr1ucUpQuljos" crossorigin="anonymous">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/brands.css" integrity="sha384-QT2Z8ljl3UupqMtQNmPyhSPO/d5qbrzWmFxJqmY7tqoTuT2YrQLEqzvVOP2cT5XW" crossorigin="anonymous">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/fontawesome.css" integrity="sha384-u5J7JghGz0qUrmEsWzBQkfvc8nK3fUT7DCaQzNQ+q4oEXhGSx+P2OqjWsfIRB8QT" crossorigin="anonymous">
    <script src="/assets/js/scale.fix.js"></script>
</noscript>
<script>
    var loadDeferredStyles = function() {
    var addStylesNode = document.getElementById("deferred-styles");
    var replacement = document.createElement("div");
    replacement.innerHTML = addStylesNode.textContent;
    document.body.appendChild(replacement)
    addStylesNode.parentElement.removeChild(addStylesNode);
    };
    var raf = window.requestAnimationFrame || window.mozRequestAnimationFrame ||
        window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
    if (raf) raf(function() { window.setTimeout(loadDeferredStyles, 0); });
    else window.addEventListener('load', loadDeferredStyles);
</script>

  </body>
</html>
